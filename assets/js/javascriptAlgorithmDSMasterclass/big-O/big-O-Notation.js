/**

BIG O NOTATION :-

  - If we have multiple implementations of the same function then we can use this to determine which implementation better.

  - It allows us a way to talk formally about how the runtime of an algorithm grows as the inputs grow.



  Big O of Objects :-

  - Use objects when you don't need order.
  - Use objects when you need fast access / insertion and removal.

  - Insertion : O(1)
  - Removal : O(1)
  - Search : O(n)
  - Access : O(1)

  - When you don't need any ordering then objects are excellent choice!


  Big O of Arrays :-

  - Ordered list
  - Used an array when you need an array.

  - Insertion : O(n)  // depends
  - Removal : O(1)    // depends
  - Search : O(n)
  - Access : O(1)


  - Push - O(1)
  - Pop - O(1)
  - shift - O(n)
  - unshift - O(n)
  - concat - O(n)
  - splice - O(n)
  - slice - O(n)
  - sort - O(n * log N)
  - foreach / map / filter / reduce , etc - O(n)

*/